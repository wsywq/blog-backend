# 个人博客后端技术文档

## 1. 技术架构

### 1.1 技术栈
- **框架**: Spring Boot 3.2.x
- **语言**: Java 17
- **数据库**: MySQL 8.0
- **缓存**: Redis 6.x
- **认证**: Spring Security + JWT
- **文档**: OpenAPI 3.0 (Swagger)
- **构建工具**: Maven
- **其他**: Spring Data JPA, Lombok, MapStruct

### 1.2 项目结构
```
src/main/java/com/blog/
├── BlogApplication.java
├── config/           # 配置类
├── controller/       # 控制器层
├── service/          # 服务层
├── repository/       # 数据访问层
├── entity/           # 实体类
├── dto/              # 数据传输对象
├── enums/            # 枚举类
├── exception/        # 异常处理
├── security/         # 安全相关
├── util/             # 工具类
└── constant/         # 常量类
```

## 2. 核心功能实现

### 2.1 项目配置

#### 2.1.1 Maven配置
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
    </parent>
    
    <groupId>com.blog</groupId>
    <artifactId>blog-backend</artifactId>
    <version>1.0.0</version>
    
    <properties>
        <java.version>17</java.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- Database -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
        </dependency>
        
        <!-- Swagger -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.2.0</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- MapStruct -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

#### 2.1.2 应用配置
```yaml
# application.yml
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  application:
    name: blog-backend
  
  datasource:
    url: jdbc:mysql://localhost:3306/blog?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
        
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: 0
      
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8

# JWT配置
jwt:
  secret: ${JWT_SECRET:your-secret-key}
  expiration: 86400000 # 24小时

# GitHub OAuth配置
github:
  client-id: ${GITHUB_CLIENT_ID:}
  client-secret: ${GITHUB_CLIENT_SECRET:}
  
# 天气API配置
weather:
  api-key: ${WEATHER_API_KEY:}
  base-url: https://api.weatherapi.com/v1

# 日志配置
logging:
  level:
    com.blog: DEBUG
    org.springframework.security: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
```

### 2.2 实体类设计

#### 2.2.1 基础实体
```java
// BaseEntity.java
@MappedSuperclass
@Data
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createTime;
    
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updateTime;
    
    @PrePersist
    protected void onCreate() {
        createTime = LocalDateTime.now();
        updateTime = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        updateTime = LocalDateTime.now();
    }
}
```

#### 2.2.2 文章实体
```java
// Article.java
@Entity
@Table(name = "articles")
@Data
@EqualsAndHashCode(callSuper = true)
public class Article extends BaseEntity {
    
    @NotBlank(message = "文章标题不能为空")
    @Column(nullable = false)
    private String title;
    
    @NotBlank(message = "文章内容不能为空")
    @Lob
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;
    
    @NotBlank(message = "文章摘要不能为空")
    @Column(nullable = false, length = 500)
    private String summary;
    
    @NotBlank(message = "作者不能为空")
    @Column(nullable = false)
    private String author;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ArticleStatus status = ArticleStatus.DRAFT;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "article_tags",
        joinColumns = @JoinColumn(name = "article_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id")
    )
    private Set<Tag> tags = new HashSet<>();
    
    @Column(length = 500)
    private String coverImage;
    
    @Column(nullable = false)
    private Long viewCount = 0L;
    
    @OneToMany(mappedBy = "article", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Comment> comments = new ArrayList<>();
}
```

### 2.3 DTO设计

#### 2.3.1 文章DTO
```java
// ArticleDto.java
public record ArticleDto(
    Long id,
    String title,
    String content,
    String summary,
    String author,
    ArticleStatus status,
    CategoryDto category,
    Set<TagDto> tags,
    String coverImage,
    Long viewCount,
    LocalDateTime createTime,
    LocalDateTime updateTime
) {
    public ArticleDto {
        Objects.requireNonNull(title, "标题不能为空");
        Objects.requireNonNull(content, "内容不能为空");
        Objects.requireNonNull(summary, "摘要不能为空");
        Objects.requireNonNull(author, "作者不能为空");
    }
}

// CreateArticleRequest.java
public record CreateArticleRequest(
    @NotBlank(message = "文章标题不能为空")
    String title,
    
    @NotBlank(message = "文章内容不能为空")
    String content,
    
    @NotBlank(message = "文章摘要不能为空")
    String summary,
    
    @NotBlank(message = "作者不能为空")
    String author,
    
    Long categoryId,
    Set<Long> tagIds,
    String coverImage
) {}

// UpdateArticleRequest.java
public record UpdateArticleRequest(
    @NotBlank(message = "文章标题不能为空")
    String title,
    
    @NotBlank(message = "文章内容不能为空")
    String content,
    
    @NotBlank(message = "文章摘要不能为空")
    String summary,
    
    @NotBlank(message = "作者不能为空")
    String author,
    
    Long categoryId,
    Set<Long> tagIds,
    String coverImage,
    ArticleStatus status
) {}
```

### 2.4 Repository层

#### 2.4.1 文章Repository
```java
// ArticleRepository.java
@Repository
public interface ArticleRepository extends JpaRepository<Article, Long> {
    
    @Query("SELECT a FROM Article a WHERE a.status = 'PUBLISHED' ORDER BY a.createTime DESC")
    Page<Article> findPublishedArticles(Pageable pageable);
    
    @Query("SELECT a FROM Article a WHERE a.status = 'PUBLISHED' AND a.category.id = :categoryId ORDER BY a.createTime DESC")
    Page<Article> findByCategoryId(@Param("categoryId") Long categoryId, Pageable pageable);
    
    @Query("SELECT a FROM Article a JOIN a.tags t WHERE a.status = 'PUBLISHED' AND t.id = :tagId ORDER BY a.createTime DESC")
    Page<Article> findByTagId(@Param("tagId") Long tagId, Pageable pageable);
    
    @Query("SELECT a FROM Article a WHERE a.status = 'PUBLISHED' AND (a.title LIKE %:keyword% OR a.content LIKE %:keyword%) ORDER BY a.createTime DESC")
    Page<Article> searchArticles(@Param("keyword") String keyword, Pageable pageable);
    
    @Query("SELECT a FROM Article a WHERE a.status = 'PUBLISHED' ORDER BY a.viewCount DESC")
    List<Article> findPopularArticles(Pageable pageable);
    
    @Query("SELECT COUNT(a) FROM Article a WHERE a.status = 'PUBLISHED'")
    long countPublishedArticles();
    
    @Modifying
    @Query("UPDATE Article a SET a.viewCount = a.viewCount + 1 WHERE a.id = :id")
    void incrementViewCount(@Param("id") Long id);
}
```

### 2.5 Service层

#### 2.5.1 文章Service
```java
// ArticleService.java
public interface ArticleService {
    Page<ArticleDto> getArticles(int page, int size, String sortBy, String sortDir);
    ArticleDto getArticleById(Long id);
    ArticleDto createArticle(CreateArticleRequest request);
    ArticleDto updateArticle(Long id, UpdateArticleRequest request);
    void deleteArticle(Long id);
    Page<ArticleDto> getArticlesByCategory(Long categoryId, int page, int size);
    Page<ArticleDto> getArticlesByTag(Long tagId, int page, int size);
    Page<ArticleDto> searchArticles(String keyword, int page, int size);
    List<ArticleDto> getPopularArticles(int limit);
    void incrementViewCount(Long id);
}

// ArticleServiceImpl.java
@Service
@Transactional
@Slf4j
public class ArticleServiceImpl implements ArticleService {
    
    @Autowired
    private ArticleRepository articleRepository;
    
    @Autowired
    private CategoryRepository categoryRepository;
    
    @Autowired
    private TagRepository tagRepository;
    
    @Autowired
    private ArticleMapper articleMapper;
    
    @Override
    public Page<ArticleDto> getArticles(int page, int size, String sortBy, String sortDir) {
        Sort sort = Sort.by(Sort.Direction.fromString(sortDir), sortBy);
        Pageable pageable = PageRequest.of(page, size, sort);
        
        Page<Article> articles = articleRepository.findPublishedArticles(pageable);
        return articles.map(articleMapper::toDto);
    }
    
    @Override
    public ArticleDto getArticleById(Long id) {
        Article article = articleRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("文章不存在: " + id));
        return articleMapper.toDto(article);
    }
    
    @Override
    public ArticleDto createArticle(CreateArticleRequest request) {
        Article article = new Article();
        article.setTitle(request.title());
        article.setContent(request.content());
        article.setSummary(request.summary());
        article.setAuthor(request.author());
        article.setCoverImage(request.coverImage());
        
        if (request.categoryId() != null) {
            Category category = categoryRepository.findById(request.categoryId())
                .orElseThrow(() -> new ResourceNotFoundException("分类不存在: " + request.categoryId()));
            article.setCategory(category);
        }
        
        if (request.tagIds() != null && !request.tagIds().isEmpty()) {
            Set<Tag> tags = tagRepository.findAllById(request.tagIds()).stream()
                .collect(Collectors.toSet());
            article.setTags(tags);
        }
        
        Article savedArticle = articleRepository.save(article);
        return articleMapper.toDto(savedArticle);
    }
    
    @Override
    public void incrementViewCount(Long id) {
        articleRepository.incrementViewCount(id);
    }
}
```

### 2.6 Controller层

#### 2.6.1 文章Controller
```java
// ArticleController.java
@RestController
@RequestMapping("/articles")
@Tag(name = "文章管理", description = "文章相关接口")
@Slf4j
public class ArticleController {
    
    @Autowired
    private ArticleService articleService;
    
    @GetMapping
    @Operation(summary = "获取文章列表")
    public ResponseEntity<ApiResponse<Page<ArticleDto>>> getArticles(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "createTime") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDir) {
        try {
            Page<ArticleDto> articles = articleService.getArticles(page, size, sortBy, sortDir);
            return ResponseEntity.ok(ApiResponse.success("获取文章列表成功", articles));
        } catch (Exception e) {
            log.error("获取文章列表失败", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("获取文章列表失败"));
        }
    }
    
    @GetMapping("/{id}")
    @Operation(summary = "获取文章详情")
    public ResponseEntity<ApiResponse<ArticleDto>> getArticleById(@PathVariable Long id) {
        try {
            ArticleDto article = articleService.getArticleById(id);
            return ResponseEntity.ok(ApiResponse.success("获取文章详情成功", article));
        } catch (ResourceNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(ApiResponse.error(e.getMessage()));
        } catch (Exception e) {
            log.error("获取文章详情失败", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("获取文章详情失败"));
        }
    }
    
    @PostMapping
    @Operation(summary = "创建文章")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<ArticleDto>> createArticle(
            @Valid @RequestBody CreateArticleRequest request) {
        try {
            ArticleDto article = articleService.createArticle(request);
            return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success("创建文章成功", article));
        } catch (Exception e) {
            log.error("创建文章失败", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("创建文章失败"));
        }
    }
    
    @PutMapping("/{id}/view")
    @Operation(summary = "更新文章访问量")
    public ResponseEntity<ApiResponse<Void>> incrementViewCount(@PathVariable Long id) {
        try {
            articleService.incrementViewCount(id);
            return ResponseEntity.ok(ApiResponse.success("更新访问量成功", null));
        } catch (Exception e) {
            log.error("更新访问量失败", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("更新访问量失败"));
        }
    }
}
```

### 2.7 安全配置

#### 2.7.1 JWT工具类
```java
// JwtUtil.java
@Component
@Slf4j
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(getSigningKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
    }
    
    private Key getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
}
```

### 2.8 异常处理

#### 2.8.1 全局异常处理器
```java
// GlobalExceptionHandler.java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<?>> handleResourceNotFoundException(ResourceNotFoundException ex) {
        log.error("资源未找到", ex);
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(ApiResponse.error(ex.getMessage()));
    }
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse<?>> handleIllegalArgumentException(IllegalArgumentException ex) {
        log.error("参数错误", ex);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error(ex.getMessage()));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<?>> handleValidationException(MethodArgumentNotValidException ex) {
        String message = ex.getBindingResult().getFieldErrors().stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining(", "));
        log.error("参数验证失败: {}", message);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error(message));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<?>> handleGenericException(Exception ex) {
        log.error("系统异常", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ApiResponse.error("系统内部错误"));
    }
}
```

## 3. 性能优化

### 3.1 缓存策略
- Redis缓存热点数据
- 文章列表缓存
- 用户信息缓存
- 天气信息缓存

### 3.2 数据库优化
- 合理使用索引
- 避免N+1查询问题
- 分页查询优化
- 连接池配置

### 3.3 异步处理
- 访问量统计异步更新
- 邮件发送异步处理
- 日志记录异步处理

## 4. 部署方案

### 4.1 Docker部署
```dockerfile
FROM openjdk:17-jdk-slim
VOLUME /tmp
COPY target/blog-backend-1.0.0.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
```

### 4.2 环境配置
- 开发环境配置
- 测试环境配置
- 生产环境配置

## 5. 监控和日志

### 5.1 日志配置
- 应用日志
- 访问日志
- 错误日志

### 5.2 监控指标
- 应用性能监控
- 数据库性能监控
- 系统资源监控
